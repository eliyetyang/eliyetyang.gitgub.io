---
title: "关于设计模式的基本原则"
categories:
  - architecture
tab:
  - design
---

关于设计模式的基本原则，由于鄙人用java开发，所以以下都是在以java的角度进行的理解。

###一 单一职能原则
<p>
这一原则还是比较好理解的，通俗的说就是一个类只做一类事情。从面向对象的设计来讲，这是对类进行定义的基本原则。
这样做有什么好处？我们反向来讲。
</p>
<p>
一方面，当一个类承担了多种职能，这些职能很有可能会有业务交叉点，而后期如果我们的业务发生改变，
导致不得不修改原有的部分功能，而之前在这个类中，业务又存在交叉，这就导致对单一职能的修改，牵连到其他的职能，
而如果整个软件设计之初都没有很好的遵循该原则，就会导致需要修改的地方非常多，并且有时这种修改对其他方法的影响难以察觉，
导致部分难以发现的BUG。
</p>
<p>
另一方面，当我需要使用该类的某一类功能时，我可能需要创建一个该类的实例，而他的其他功能是我不需要的，这时就导致了资源的浪费，
这和接口隔离原则也有共通点，当然这是因为本身面向对象的设计很大程度是为了复用，单一的职能有利于这种复用，所以单一职能在复用时也是一种对资源的节省。
但实际上。这条原则是很难完全遵守的，如何定义一类功能中的一类，本身就是比较模糊的。打个比方，我定一个洗衣机的类，里面有洗衣服相关的功能。
比如，浸泡，洗衣，甩干等。那么这是我的对一类的定义，是洗衣服。但后来我的业务发生了改变，当我要洗衬衫的时候，只需要浸泡，衣服使用手洗并且不用甩干。
这时其他两个功能就是多余的，而且我设计洗衣机这个类的时候，是全自动，浸泡洗衣甩干一条龙服务，我只能对原来的代码进行大规模的修改，并把浸泡这一功能拿出来，
单独定一个类。这是这一类功能就进行了进一步的细化————浸泡这一类职能。
</p>
<p>
这两种分类方式都没有错，只是粒度不同，我们不能无限制的细分职能，粒度过小，会让类的种类繁多，使软件复杂花并陷入过渡设计之中。
在进行设计的时候，要根据实际项目情况，合理的对项目粒度进行划分，避免过的的设计让软件过分的复杂，而如何划分就凭设计者的经验了。
还有一点要讲一下我的观念，不要怕重构，一个软件很难在他设计之初就考虑的尽善尽美，重构推进代码是难免的，只要我们在设计之初尽自己所能，并有一个良好的编码习惯，
后期逐步进行重构，将代码向前推进，一步一步一定会写出一个拓展性强耦合度低健壮性高的软件来。
</p>

###二 开闭原则
<p>
从字面上来理解，开————开放————对拓展开放；闭————关闭————对修改关闭。
</p>
<p>
简单说，已经写好的类，尽量不要去修改已有的代码，而是去进行拓展，也就是添加新的代码。
</p>
<p>
这就要求在对类进行设计的时候，充分的对其进行抽象。哪些方法是固定不变的，哪些方法有可能会有不同实现的。
在需求变化或增加的时候，通过继承，对可变方法进行重写或实现，来达到新的需求。这就是对拓展开放，对修改关闭。
</p>
<p>
这样做有几个好处：
</p>
<p>
第一，可以更好的兼容以往的版本。对修改的关闭，意味着已经稳定运行的部分不会更改，也就是新功能的添加不会导致以往功能出现问题。
而对原有代码进行修改，之前说过，一方面可能会导致一系列的修改，增加不稳定因素和过多的工作量，另一方面，
对原有代码的修改会增加其他环节的成本，如设计及测试等。
</p>
<p>
第二，可以有更多的选择性。有时候产品的需求是摇摆不定的，今天让你按A方案来做，明天可能就是B方案，而后天又要改回A方案。
单纯的对代码进行拓展而不是修改，会让你在对功能进行实现的时候有更多的选择性，进一步减少你的工作量，当然这种摇摆的需求你可以通过GIT等版本控制器来实现，
但这是项目管理上的，而在软件的设计上，你可以通过拓展来应对这种需求的变更，而且之前说的只是A改B，一旦要求你根据实际情况选择AB方案怎么办。
</p>
<p>
当然，这依然是个美好的愿景，也不可能完全遵循该原则。过渡的抽象也会导致软件负责度增高,并且复用率低。
都是抽象的了，每次有个新需求所有方法都重新实现，自然复用率低复杂度高。
所以还是那句话，适度抽象，具体能做到什么程度，还是要看个人经验和项目的实际情况。
</p>
<p>
例子继续搬出我们的洗衣机（别问我为什么是洗衣机，我不会告诉你今天正好洗衣服的-_-！）
</p>
<p>
我们的洗衣机最开始只是单纯的一条龙服务，没有什么可以选择的，
因为单一职能原则又把浸泡功能分离为一个单独的类。现在想象嗨哟还有设么不足呢？洗衣的方式是不是太少了？
当初为什么不用它来洗衬衫？还不是机洗没法洗干净衣领。如果有种针对衣领做特别处理的洗衣方式就好了。
那么我们把这个方法抽象出来，那甩干需要抽象么？在可预见的日子里，甩干好像只有离心着一种方法，没有抽象的必要，
作为共有的甩干方吧，还怕有人乱搞的话在给甩干加个final，这样把原有的洗衣机类作为基类，定义抽象法发洗衣，
定义默认实现方法甩干，拥有一个成员变量浸泡，使用该变量进行浸泡功能。分别创建默认洗衣机类与衣领特别处理洗衣机类，
继承洗衣机基类，分别实现默认洗衣方法和衣领特殊处理洗衣方法。好的现在即能洗普通的衣服又能洗衬衫了～
</p>